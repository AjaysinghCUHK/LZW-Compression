# LZW-Compression
The LZW algorithm is based on the LZ77 algorithm, which is proposed by A. Lempel and J. Ziv in 1977. Like LZ77 and LZ78, LZW is a dictionary based compression algorithm and does not perform any analysis on the input text. LZW is widely known for its application in GIF and in the V.42 communication standard.

Archiving multiple files is not currently working. The program will compress all the files into one compressed file but, decompressing the file will only output one file with the .txt format. You can manually change the format of the output file to what it was and it should work completely fine. 

During compression, we create a dictionary of strings on the fly. A code corresponds to the location of a string in the dictionary. Assume we are at a particular instance of compression, a new character is read from the input text. Then, we search for the presence of the new string that is created by appending the character to the prefix P in the dictionary. If this string could be found, we will use the new string as the prefix and repeat the search by appending another new character. Meanwhile, the codeword is memorized. Conceptually, the iteration is equivalent to reading the longest string that is already contained in the dictionary. When the string could not be found, we will output the codeword for the prefix and add a new entry to the dictionary. A practical issue about implementation is how to store the dictionary. Obviously, a linear array suffices, but the performance will be unacceptable since the dictionary lookup step will take too much time. Alternatives will be to use a tree structure or a hashing function. I made use of a Hash Table to speed up the compression. 

The decompression process is even easier to understand. It is basically the reverse of the compression process. For a code read from the input stream, the decompression routine will output the corresponding entry in the dictionary and update the dictionary. In closer examination, one would find that the decompression process actually lags behind the compression process. Hence, there will be the case when a code refers to an entry that has not yet been created. To handle this, we just need to follow the routines. Besides, cautions must be taken when a new dictionary is created in the middle of the decompression process.
